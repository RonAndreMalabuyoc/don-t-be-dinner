[gd_scene load_steps=56 format=3 uid="uid://dl6d3lwiivjxg"]

[ext_resource type="Texture2D" uid="uid://bm5w7ih0ujtsx" path="res://assets/winning_dance-Sheet.png" id="1_2q423"]
[ext_resource type="Texture2D" uid="uid://b24tj1r88ew7v" path="res://assets/idle_right-Sheet.png" id="1_48ufq"]
[ext_resource type="PackedScene" uid="uid://0c7kqgockbqo" path="res://scenes/Bullets/BreadBullet_Throw.tscn" id="1_ogw1n"]
[ext_resource type="Texture2D" uid="uid://drv57nqyv7011" path="res://assets/jump_right-Sheet.png" id="2_uvl38"]
[ext_resource type="Texture2D" uid="uid://dio8s4h1seupc" path="res://assets/walk_right-Sheet.png" id="2_wmkwl"]
[ext_resource type="Texture2D" uid="uid://dcku5knbb872k" path="res://assets/Duck/24_hurtduck_left-Sheet.png" id="4_0d0nc"]
[ext_resource type="Texture2D" uid="uid://xfs8i5sosg3v" path="res://assets/shoot_right_duck-Sheet.png" id="6_2v62t"]
[ext_resource type="AudioStream" uid="uid://eudp7igamm7n" path="res://SFX/Quack 1.wav" id="8_pvtuh"]
[ext_resource type="Script" uid="uid://c1jhbscky8a3u" path="res://scenes/camera_2d.gd" id="8_qoi8n"]
[ext_resource type="AudioStream" uid="uid://cxsj25mtfcsfi" path="res://SFX/hurt_quack.wav" id="9_8rh4e"]
[ext_resource type="AudioStream" uid="uid://ce87l57f5k2f4" path="res://SFX/Shoot.wav" id="10_is85u"]
[ext_resource type="AudioStream" uid="uid://bqp7v03q2heb1" path="res://SFX/Dash.wav" id="11_o67j2"]
[ext_resource type="AudioStream" uid="uid://ddcww4fbcms5e" path="res://SFX/jump_land.wav" id="13_8rh4e"]
[ext_resource type="AudioStream" uid="uid://e5pg3sge6mv7" path="res://SFX/walk_player.wav" id="14_is85u"]
[ext_resource type="AudioStream" uid="uid://7pdn5m3xkmnn" path="res://SFX/Fruit_collect.wav" id="14_wtvrk"]
[ext_resource type="AudioStream" uid="uid://dl3bp2lwggooe" path="res://SFX/The Duck Song.wav" id="16_is85u"]

[sub_resource type="GDScript" id="GDScript_48ufq"]
resource_name = "Movement"
script/source = "extends CharacterBody2D

# ─── SIGNALS ───
signal health_changed(current_hp, max_hp)

# ─── CONFIGURATION ───
const HP_PER_HEART := 10  # 1 Heart visual = 10 HP actual
@export var base_hearts := 3

# ───────── MOVEMENT ─────────
@export_group(\"Movement\")
@export var speed := 400
@export var jump_force := -600
@export var gravity := 1200
@export var hurt_knockback_damp := 1800.0
var was_on_floor := false
var jump_anim_requested := false
var jumps_done := 0
var max_jumps := 1
var facing_right := true

# ───────── DASH ─────────
@export_group(\"Dash\")
@export var dash_speed := 900.0
@export var dash_duration := 0.12
@export var dash_cooldown := 1.5

var is_dashing := false
var is_dodging := false # Used for state checking
var can_dash := true
var dash_time_left := 0.0
var dash_dir := 0.0

# ───────── COMBAT & SHOOTING ─────────
@export_group(\"Combat\")
@export var shoot_cooldown := 0.3
@export var bullet_scene: PackedScene
@export var base_damage := 10 
const SHOOT_FRAME := 3
var is_shooting := false
var can_shoot := true
var shot_fired_this_anim := false

# ───────── FRUIT SHOOTING ─────────
@export_group(\"Fruit System\")
@export var fruit_shoot_cooldown := 0.3
@export var fruit_projectiles := {
	\"Pomegranate\": preload(\"res://scenes/Bullets/PomegranateBullet_Throw.tscn\"),
	\"Orange\": preload(\"res://scenes/Bullets/OrangeBullet_Throw.tscn\"),
	\"Banana\": preload(\"res://scenes/Bullets/BananaBullet_Throw.tscn\"),
	\"Coconut\": preload(\"res://scenes/Bullets/CoconutBullet_Throw.tscn\"),
}
var can_shoot_fruit := true
var _fruit_shot_seq := 0
var current_fruit: String = \"\"
var reserve_fruit: String = \"\"

# ───────── HEALTH & STATES ─────────
var max_health := 30 
var current_health := 30

@export_group(\"Survival\")
@export var hurt_lock_time := 0.25
@export var invulnerability_time := 1.3
@export var blink_interval := 0.1

var is_invulnerable := false
var is_dead := false
var can_take_damage := true
var is_hurt := false
var hurt_dir := 0
var is_emoting := false

# ───────── NODES ─────────
@onready var sprite: AnimatedSprite2D = $AnimatedSprite2D
@onready var shoot_point: Node2D = $ShootPoint
@onready var hitbox: Area2D = $Hitbox
@onready var camera: Camera2D = $Camera2D

# UI Nodes (Fetched dynamically, handled safely)
@onready var fruit_ui_current: Label = get_tree().current_scene.get_node_or_null(\"HUD/FruitUI/Current_fruit\")
@onready var fruit_ui_reserve: Label = get_tree().current_scene.get_node_or_null(\"HUD/FruitUI/Reserve_fruit\")

# ───────── SFX ─────────
@onready var quack_player = $QuackPlayer
@onready var hurt_player = $HurtPlayer
@onready var shoot_player = $ShootPlayer
@onready var dash_player = $DashPlayer
@onready var land_player = $LandPlayer
@onready var walk_player = $WalkPlayer
@onready var pickup_player = $PickupPlayer
@onready var dance_player = $DancePlayer
var bg_music_node: AudioStreamPlayer = null
var quack_timer := 0.0

# ───────── INITIALIZATION ─────────
func _ready():
	print(\"PLAYER READY:\", get_path())
	print(\"----- HEALTH DEBUG -----\")
	print(\"Base Hearts Setting: \", base_hearts)
	print(\"Calculated Max HP: \", max_health)
	print(\"Current HP: \", current_health)
	print(\"------------------------\")
	# Global Setup
	Global.node_creation_parent = self
	Global.playerbody = self
	Global.player_alive = true
	
	bg_music_node = get_tree().current_scene.get_node_or_null(\"MusicPlayer\")
	if bg_music_node == null:
		# Fallback in case it's named differently
		bg_music_node = get_tree().current_scene.get_node_or_null(\"AudioStreamPlayer\")
	# Skill Setup
	SkillManager.apply_existing_skills_to_player()
	
	if SkillManager.health_boost_active:
		max_health = (base_hearts + 1) * HP_PER_HEART
	else:
		max_health = base_hearts * HP_PER_HEART
		
	# Initialize HP
	current_health = max_health
	
	if \"health\" in Global:
		Global.health = max_health
	elif \"current_health\" in Global:
		Global.current_health = max_health
	elif \"hp\" in Global:
		Global.hp = max_health
		
	if SkillManager.dash_mastery_active:
		apply_dash_mastery()
	
	# Wait for frame to ensure UI is ready
	await get_tree().process_frame
	health_changed.emit(current_health, max_health)
	_update_fruit_ui()
	
	# Connections
	hitbox.body_entered.connect(_on_hitbox_body_entered)
	hitbox.area_entered.connect(_on_hitbox_area_entered)
	sprite.frame_changed.connect(_on_sprite_frame_changed)
	
	# Ambient SFX
	if quack_player:
		quack_player.play()
		quack_timer = randf_range(6.0, 14.0)

# ───────── PHYSICS LOOP ─────────
func _physics_process(delta):
	if is_dead: return

	# 1. HANDLE HURT KNOCKBACK
	if is_hurt:
		velocity.y += gravity * delta
		velocity.x = move_toward(velocity.x, 0, hurt_knockback_damp * delta)
		if is_on_floor():
			velocity.x = move_toward(velocity.x, 0, hurt_knockback_damp * 2 * delta)
		move_and_slide()
		return # Skip other controls while hurt

	# 2. HANDLE DASHING
	if is_dashing:
		dash_time_left -= delta
		velocity.x = dash_dir * dash_speed
		velocity.y = 0
		move_and_slide()
		if dash_time_left <= 0:
			stop_dash()
		return # Skip other controls while dashing

	# 3. HANDLE EMOTES (FIXED)
	if Input.is_action_just_pressed(\"dance\"):
		is_emoting = !is_emoting
		
		# Play audio ONCE when button is pressed
		if is_emoting:
			if dance_player: dance_player.play(3.50)
			if bg_music_node: bg_music_node.stream_paused = true
		else:
			if dance_player: dance_player.stop()
			if dance_player: dance_player.stop()
			if bg_music_node: bg_music_node.stream_paused = false
	if is_emoting:
		velocity.x = 0
		velocity.y += gravity * delta
		handle_animations()
		move_and_slide()
		return # Stop here only if dancing. If not dancing, continue down!

	# 4. STANDARD MOVEMENT (Now this code will actually run!)
	# Gravity
	if not is_on_floor():
		velocity.y += gravity * delta
	else:
		jumps_done = 0

	# Inputs
	if Input.is_action_just_pressed(\"jump\"):
		if is_on_floor() or jumps_done < max_jumps:
			velocity.y = jump_force
			jumps_done += 1
			jump_anim_requested = true
	
	# Horizontal Movement
	var direction := Input.get_axis(\"Left\", \"Right\")
	if direction != 0:
		velocity.x = direction * speed
		facing_right = direction > 0
	else:
		velocity.x = move_toward(velocity.x, 0, 40)

	# Actions
	if Input.is_action_just_pressed(\"dash\") and can_dash:
		start_dash()

	if Input.is_action_pressed(\"shoot\") and can_shoot:
		start_shoot()
		
	if Input.is_action_just_pressed(\"fruit_shoot\"):
		shoot_fruit()

	if Input.is_action_just_pressed(\"swap_fruit\"):
		swap_fruit_slots()

	# 5. FINAL UPDATES
	handle_animations()
	sprite.flip_h = not facing_right
	move_and_slide()
	
	# SFX Updates
	_handle_audio_process(delta)
	
func _handle_audio_process(delta):
	# ─── 1. LANDING SFX ───
	# Logic: If not on floor previous frame, but on floor now = Landed
	if not was_on_floor and is_on_floor():
		print(\"DEBUG: Land detected!\") # Check your Output console for this
		if land_player: 
			land_player.play()
		else:
			print(\"ERROR: LandPlayer node is missing or not assigned!\")

	# ─── 2. AMBIENT QUACK ───
	quack_timer -= delta
	if quack_timer <= 0.0:
		if quack_player: quack_player.play()
		quack_timer = randf_range(6.0, 14.0)

	# ─── 3. WALKING SFX ───
	if is_on_floor():
		# FIX: Removed \"velocity.y == 0\". 
		# We only care if we are moving horizontally (abs(x) > 10)
		if abs(velocity.x) > 10:
			if walk_player:
				if not walk_player.playing: 
					walk_player.play()
			else:
				print(\"ERROR: WalkPlayer node is missing!\")
		else:
			# We are on floor but standing still
			if walk_player: walk_player.stop()
	else:
		# We are in the air
		if walk_player: walk_player.stop()
	
	# Update history for the next frame
	was_on_floor = is_on_floor()
# ───────── SKILLS & POWERUPS ─────────
func apply_dash_mastery():
	dash_speed *= 1.25
	dash_cooldown *= 0.7

func apply_double_jump():
	max_jumps = 2
	print(\"Double Jump unlocked! Max jumps:\", max_jumps)

func apply_swift_feet():
	speed = int(speed * 1.2)
	print(\"Swift Feet applied! New speed:\", speed)
	
func apply_sharp_blows():
	base_damage = int(base_damage * 2.0)
	print(\"Sharp Blows applied! New damage:\", base_damage)

func apply_quick_recovery():
	hurt_lock_time *= 0.5
	invulnerability_time *= 0.5
	print(\"Quick Recovery applied!\")

# ───────── ACTIONS ─────────
func start_dash():
	can_dash = false
	is_dashing = true
	is_dodging = true
	is_invulnerable = true
	can_take_damage = false
	hitbox.monitoring = false
	dash_time_left = dash_duration

	var input_dir := Input.get_axis(\"Left\", \"Right\")
	if input_dir != 0:
		dash_dir = sign(input_dir)
	else:
		dash_dir = 1 if facing_right else -1
	facing_right = dash_dir > 0
	
	if dash_player: dash_player.play()

	await get_tree().create_timer(dash_cooldown).timeout
	can_dash = true

func stop_dash():
	is_dashing = false
	is_dodging = false
	is_invulnerable = false
	can_take_damage = true
	hitbox.monitoring = true
	velocity.x = move_toward(velocity.x, 0, 200)
	sprite.modulate = Color.WHITE

func get_shoot_direction() -> Vector2:
	var mouse_pos = get_global_mouse_position()
	return (mouse_pos - shoot_point.global_position).normalized()

func start_shoot():
	if not can_shoot: return
	can_shoot = false
	is_shooting = true
	shot_fired_this_anim = false
	
	# Face mouse when shooting
	facing_right = get_global_mouse_position().x > global_position.x
	
	sprite.play(\"shoot\")
	await sprite.animation_finished
	
	is_shooting = false
	await get_tree().create_timer(shoot_cooldown).timeout
	can_shoot = true

func _on_sprite_frame_changed():
	if sprite.animation == \"shoot\" and sprite.frame == SHOOT_FRAME and not shot_fired_this_anim:
		shot_fired_this_anim = true
		fire_bullet()

func fire_bullet():
	if not bullet_scene or not Global.node_creation_parent: return
	
	var bullet = Global.instance_node(bullet_scene, shoot_point.global_position, Global.node_creation_parent)
	if bullet:
		if \"direction\" in bullet: bullet.direction = get_shoot_direction()
		if \"damage\" in bullet: bullet.damage = base_damage
	
	if shoot_player: shoot_player.play()

# ───────── FRUIT LOGIC ─────────
func shoot_fruit() -> void:
	if not can_shoot_fruit or current_fruit == \"\": return
	
	var fruit_id := current_fruit
	if not fruit_projectiles.has(fruit_id): return

	_fruit_shot_seq += 1
	var seq := _fruit_shot_seq
	can_shoot_fruit = false

	# Instantiate
	var proj_scene: PackedScene = fruit_projectiles[fruit_id]
	var proj = Global.instance_node(proj_scene, shoot_point.global_position, Global.node_creation_parent)
	var dir := get_shoot_direction()
	
	if proj:
		if \"direction\" in proj: proj.direction = dir
		elif proj.has_method(\"setup\"): proj.call(\"setup\", dir)

	# Animation
	is_shooting = true
	sprite.play(\"shoot\")
	await sprite.animation_finished
	is_shooting = false

	# Inventory Management
	if seq == _fruit_shot_seq: # Ensure sequence hasn't been interrupted
		current_fruit = \"\"
		if reserve_fruit != \"\":
			current_fruit = reserve_fruit
			reserve_fruit = \"\"
		_update_fruit_ui()
		
		await get_tree().create_timer(fruit_shoot_cooldown).timeout
		if seq == _fruit_shot_seq:
			can_shoot_fruit = true

func swap_fruit_slots() -> void:
	if current_fruit == \"\" and reserve_fruit == \"\": return
	var tmp := current_fruit
	current_fruit = reserve_fruit
	reserve_fruit = tmp
	_update_fruit_ui()

func push_powerup(item_id: String, _duration: float = -1.0, _auto_fire: bool = false) -> void:
	if current_fruit == \"\": current_fruit = item_id
	elif reserve_fruit == \"\": reserve_fruit = item_id
	else: reserve_fruit = item_id # Replace reserve if full
	
	if pickup_player: 
		pickup_player.play(3.58)
	_update_fruit_ui()

func _update_fruit_ui() -> void:
	if is_instance_valid(fruit_ui_current):
		fruit_ui_current.text = \"Current: \" + (current_fruit if current_fruit != \"\" else \"(empty)\")
	if is_instance_valid(fruit_ui_reserve):
		fruit_ui_reserve.text = \"Reserve: \" + (reserve_fruit if reserve_fruit != \"\" else \"(empty)\")

# ───────── HEALTH & DAMAGE ─────────
func _on_hitbox_body_entered(body):
	if is_dead or not can_take_damage: return
	if body.is_in_group(\"Enemy\") and \"damage_amount\" in body:
		hurt_dir = sign(global_position.x - body.global_position.x)
		take_damage(body.damage_amount)

func _on_hitbox_area_entered(area):
	if is_dead or not can_take_damage: return
	if area.is_in_group(\"EnemyDamage\"):
		hurt_dir = sign(global_position.x - area.global_position.x)
		take_damage(10)

func take_damage(amount: int):
	if is_dead or is_hurt or is_invulnerable: return

	# 1. VISUALS / AUDIO
	if is_emoting:
		is_emoting = false
		if dance_player: dance_player.stop()
		if bg_music_node: bg_music_node.stream_paused = false 
	print(\"DEBUG: Enemy hit for \", amount, \" damage. Current HP: \", current_health)

	current_health -= amount
	
	# 4. SYNC TO GLOBAL
	# We force Global to match our local health
	if \"health\" in Global: Global.health = current_health
	elif \"current_health\" in Global: Global.current_health = current_health
	elif \"hp\" in Global: Global.hp = current_health
	
	health_changed.emit(current_health, max_health)
	
	Global.take_damage(0) 

	if current_health <= 0:
		die()
	else:
		start_hurt_and_invincibility()
		
func start_hurt_and_invincibility():
	is_hurt = true
	is_invulnerable = true
	can_take_damage = false
	hitbox.monitoring = false
	
	# Visual Knockback
	facing_right = hurt_dir < 0
	sprite.flip_h = not facing_right
	velocity.x = hurt_dir * 320
	velocity.y = -220
	
	sprite.stop()
	sprite.play(\"hurt\")
	if hurt_player: hurt_player.play()
	
	await sprite.animation_finished
	is_hurt = false
	start_blinking()

func start_blinking():
	var elapsed := 0.0
	while elapsed < invulnerability_time:
		sprite.visible = !sprite.visible
		await get_tree().create_timer(blink_interval).timeout
		elapsed += blink_interval
	
	end_invulnerability()

func end_invulnerability():
	is_invulnerable = false
	can_take_damage = true
	hitbox.monitoring = true
	sprite.visible = true

func update_max_health():
	# For Heart Containers: Increase Max but NOT current
	max_health += HP_PER_HEART
	health_changed.emit(current_health, max_health)

func heal(amount: int):
	# Cap health at max
	if current_health >= max_health: return
	
	current_health = min(current_health + amount, max_health)
	
	if \"health\" in Global:
		Global.health = current_health
	elif \"current_health\" in Global:
		Global.current_health = current_health
	elif \"hp\" in Global:
		Global.hp = current_health
		
	print(\"Healed! New HP:\", current_health)
	health_changed.emit(current_health, max_health) 
	health_changed.emit(current_health, max_health)

func on_wave_completed():
	if is_dead: return
	if SkillManager.wave_recovery_active:
		heal(HP_PER_HEART) # Heal 1 Heart

# ───────── DEATH ─────────
func die():
	if is_dead: return
	is_dead = true
	Global.player_alive = false
	
	# 1. Stop Physics/Input
	set_physics_process(false)
	set_process(false)
	if hitbox: hitbox.set_deferred(\"monitoring\", false)
	
	# 2. Visuals
	sprite.play(\"hurt\")
	
	# 3. FIX: Force Camera to update even when game is paused
	if camera:
		# This ensures the camera keeps working when we pause the tree below
		camera.process_mode = Node.PROCESS_MODE_ALWAYS 
		
		var cam_tween = create_tween().set_pause_mode(Tween.TWEEN_PAUSE_PROCESS)
		cam_tween.tween_property(camera, \"zoom\", Vector2(3, 3), 0.5).set_trans(Tween.TRANS_CUBIC).set_ease(Tween.EASE_OUT)

	# 4. Spin Effect
	var tween = create_tween().set_parallel(true).set_pause_mode(Tween.TWEEN_PAUSE_PROCESS)
	tween.tween_property(sprite, \"modulate\", Color(1, 0, 0, 0), 1.5)
	tween.tween_property(sprite, \"rotation_degrees\", 360, 1.0)

	# 5. Pause the rest of the game (Enemies, etc)
	get_tree().paused = true

	# 6. Wait before showing death screen
	await get_tree().create_timer(2.0).timeout
	
	var death_screen_path = \"res://scenes/UI/death_screen.tscn\"
	if ResourceLoader.exists(death_screen_path):
		var death_scene = load(death_screen_path)
		var instance = death_scene.instantiate()
		get_tree().root.add_child(instance) 
		Input.set_mouse_mode(Input.MOUSE_MODE_VISIBLE)
		queue_free()
	else:
		print(\"ERROR: Death screen missing.\")
		get_tree().paused = false
		get_tree().reload_current_scene()

# ───────── ANIMATION HANDLER ─────────
func handle_animations():
	if is_hurt or is_dead or is_shooting: return
	
	if is_emoting:
			sprite.play(\"dance\")
			return
	# Face Mouse if shooting intent
	if Input.is_action_pressed(\"shoot\"):
		var mouse_x := get_global_mouse_position().x
		facing_right = mouse_x > global_position.x

	# Dash overrides
	if is_dashing:
		sprite.modulate = Color(1, 1, 1, 0.6)
		sprite.play(\"dash\" if sprite.sprite_frames.has_animation(\"dash\") else \"walk\")
		return

	# Air
	if not is_on_floor():
		if jump_anim_requested:
			sprite.stop()
			sprite.play(\"jump\")
			jump_anim_requested = false
		elif velocity.y > 0:
			if sprite.sprite_frames.has_animation(\"fall\"):
				sprite.play(\"fall\")
			else:
				sprite.play(\"jump\")
		return

	# Ground
	if abs(velocity.x) > 10: 
		sprite.play(\"walk\")
	else: 
		sprite.play(\"idle\")
"

[sub_resource type="AtlasTexture" id="AtlasTexture_qthh5"]
atlas = ExtResource("1_2q423")
region = Rect2(0, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_1vudk"]
atlas = ExtResource("1_2q423")
region = Rect2(32, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_k7f46"]
atlas = ExtResource("1_2q423")
region = Rect2(64, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_wtyc1"]
atlas = ExtResource("1_2q423")
region = Rect2(96, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_wevls"]
atlas = ExtResource("1_2q423")
region = Rect2(128, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_8013f"]
atlas = ExtResource("1_2q423")
region = Rect2(160, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_ogw1n"]
atlas = ExtResource("6_2v62t")
region = Rect2(96, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_0d0nc"]
atlas = ExtResource("6_2v62t")
region = Rect2(128, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_d3a2h"]
atlas = ExtResource("6_2v62t")
region = Rect2(160, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_0ltrl"]
atlas = ExtResource("4_0d0nc")
region = Rect2(0, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_kvjf6"]
atlas = ExtResource("4_0d0nc")
region = Rect2(32, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_hj3w6"]
atlas = ExtResource("4_0d0nc")
region = Rect2(64, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_hodpe"]
atlas = ExtResource("4_0d0nc")
region = Rect2(96, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_wmkwl"]
atlas = ExtResource("1_48ufq")
region = Rect2(0, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_uvl38"]
atlas = ExtResource("1_48ufq")
region = Rect2(32, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_2q423"]
atlas = ExtResource("1_48ufq")
region = Rect2(64, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_8yqgs"]
atlas = ExtResource("1_48ufq")
region = Rect2(96, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_jw0ju"]
atlas = ExtResource("1_48ufq")
region = Rect2(128, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_2v62t"]
atlas = ExtResource("1_48ufq")
region = Rect2(160, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_47qjj"]
atlas = ExtResource("2_uvl38")
region = Rect2(96, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_dypn8"]
atlas = ExtResource("2_uvl38")
region = Rect2(128, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_07ek2"]
atlas = ExtResource("2_uvl38")
region = Rect2(160, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_kg3iu"]
atlas = ExtResource("2_uvl38")
region = Rect2(192, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_mjyag"]
atlas = ExtResource("2_uvl38")
region = Rect2(224, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_tiulj"]
atlas = ExtResource("6_2v62t")
region = Rect2(224, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_bdwkj"]
atlas = ExtResource("6_2v62t")
region = Rect2(192, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_pmoru"]
atlas = ExtResource("6_2v62t")
region = Rect2(160, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_2g5xf"]
atlas = ExtResource("6_2v62t")
region = Rect2(128, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_0yo88"]
atlas = ExtResource("6_2v62t")
region = Rect2(96, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_dbwko"]
atlas = ExtResource("6_2v62t")
region = Rect2(64, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_ei42f"]
atlas = ExtResource("6_2v62t")
region = Rect2(32, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_auo7h"]
atlas = ExtResource("6_2v62t")
region = Rect2(0, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_wcpx6"]
atlas = ExtResource("2_wmkwl")
region = Rect2(0, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_u3evn"]
atlas = ExtResource("2_wmkwl")
region = Rect2(32, 0, 32, 32)

[sub_resource type="AtlasTexture" id="AtlasTexture_5q0wt"]
atlas = ExtResource("2_wmkwl")
region = Rect2(64, 0, 32, 32)

[sub_resource type="SpriteFrames" id="SpriteFrames_wcpx6"]
animations = [{
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_qthh5")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_1vudk")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_k7f46")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_wtyc1")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_wevls")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_8013f")
}],
"loop": true,
"name": &"dance",
"speed": 8.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_ogw1n")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_0d0nc")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_d3a2h")
}],
"loop": true,
"name": &"dash",
"speed": 5.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_0ltrl")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_kvjf6")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_hj3w6")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_hodpe")
}],
"loop": false,
"name": &"hurt",
"speed": 4.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_wmkwl")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_uvl38")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_2q423")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_8yqgs")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_jw0ju")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_2v62t")
}],
"loop": true,
"name": &"idle",
"speed": 8.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_47qjj")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_dypn8")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_07ek2")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_kg3iu")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_mjyag")
}],
"loop": false,
"name": &"jump",
"speed": 5.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_tiulj")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_bdwkj")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_pmoru")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_2g5xf")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_0yo88")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_dbwko")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_ei42f")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_auo7h")
}],
"loop": false,
"name": &"shoot",
"speed": 12.0
}, {
"frames": [{
"duration": 1.0,
"texture": SubResource("AtlasTexture_wcpx6")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_u3evn")
}, {
"duration": 1.0,
"texture": SubResource("AtlasTexture_5q0wt")
}],
"loop": true,
"name": &"walk",
"speed": 6.0
}]

[sub_resource type="RectangleShape2D" id="RectangleShape2D_qoi8n"]
size = Vector2(36, 94)

[sub_resource type="RectangleShape2D" id="RectangleShape2D_pvtuh"]
size = Vector2(36, 94)

[node name="Player" type="CharacterBody2D"]
z_index = 5
collision_layer = 33
collision_mask = 33
script = SubResource("GDScript_48ufq")
jump_force = -900
gravity = 1800
dash_duration = 0.25
bullet_scene = ExtResource("1_ogw1n")

[node name="AnimatedSprite2D" type="AnimatedSprite2D" parent="."]
position = Vector2(0.5, -9.5)
scale = Vector2(3.15625, 3.21875)
sprite_frames = SubResource("SpriteFrames_wcpx6")
animation = &"hurt"
frame = 2
frame_progress = 1.0

[node name="Hitbox" type="Area2D" parent="."]
collision_layer = 33
collision_mask = 33

[node name="CollisionShape2D" type="CollisionShape2D" parent="Hitbox"]
position = Vector2(-3, -8)
shape = SubResource("RectangleShape2D_qoi8n")

[node name="ShootPoint" type="Marker2D" parent="."]
position = Vector2(-31, -29)

[node name="Camera2D" type="Camera2D" parent="."]
position = Vector2(0, -141)
position_smoothing_enabled = true
script = ExtResource("8_qoi8n")

[node name="Reload_speed" type="Timer" parent="."]
wait_time = 0.75
autostart = true

[node name="CollisionShape2D" type="CollisionShape2D" parent="."]
position = Vector2(-3, -8)
shape = SubResource("RectangleShape2D_pvtuh")

[node name="QuackPlayer" type="AudioStreamPlayer2D" parent="."]
stream = ExtResource("8_pvtuh")

[node name="HurtPlayer" type="AudioStreamPlayer2D" parent="."]
stream = ExtResource("9_8rh4e")

[node name="ShootPlayer" type="AudioStreamPlayer2D" parent="."]
stream = ExtResource("10_is85u")

[node name="DashPlayer" type="AudioStreamPlayer2D" parent="."]
stream = ExtResource("11_o67j2")

[node name="LandPlayer" type="AudioStreamPlayer2D" parent="."]
stream = ExtResource("13_8rh4e")

[node name="WalkPlayer" type="AudioStreamPlayer2D" parent="."]
stream = ExtResource("14_is85u")

[node name="PickupPlayer" type="AudioStreamPlayer2D" parent="."]
stream = ExtResource("14_wtvrk")

[node name="DancePlayer" type="AudioStreamPlayer2D" parent="."]
stream = ExtResource("16_is85u")

[connection signal="timeout" from="Reload_speed" to="." method="_on_timer_timeout"]
